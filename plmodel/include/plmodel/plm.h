/*
MIT License

Copyright (c) 2017-2021 Mark E Sowden <hogsy@oldtimes-software.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#pragma once

#include <plcore/pl.h>
#include <plcore/pl_math.h>
#include <plcore/pl_physics.h>

#include <plgraphics/plg.h>
#include <plgraphics/plg_mesh.h>

typedef struct PLAnimationFrame {
	QmMathVector3f transform;
} PLAnimationFrame;

typedef struct PLAnimation {
	char name[ 64 ];
	PLAnimationFrame *frames;
	uint32_t num_frames;
	float framerate;
} PLAnimation;

////////////////////////////////////////////////////////////////////////////

typedef enum PLMModelType {
	PLM_MODELTYPE_STATIC,   /* static non-animated */
	PLM_MODELTYPE_VERTEX,   /* per-vertex animated */
	PLM_MODELTYPE_SKELETAL, /* skeletal/bones animated */

	PLM_NUM_MODELTYPES
} PLMModelType;

typedef struct PLMVertexAnimationFrame {
	/* todo: store submeshes into PLMesh struct */
	PLGMesh **meshes;
	uint32_t num_meshes;
} PLMVertexAnimationFrame;

typedef struct PLMVertexAnimModelData {
	uint32_t current_animation; /* current animation index */
	uint32_t current_frame;     /* current animation frame */
	PLMVertexAnimationFrame *animations;
} PLMVertexAnimModelData;

/* * * * * * * * * * * * * * * * * */
/* Skeletal Model Data */

#define PLM_MAX_BONE_WEIGHTS 4

typedef struct PLMBoneWeight {
	struct {
		unsigned int boneIndex;
		float factor;
	} subWeights[ PLM_MAX_BONE_WEIGHTS ];
	unsigned int numSubWeights;
} PLMBoneWeight;

typedef struct PLMModelBone {
	char name[ 64 ];
	unsigned int parent;
	QmMathVector3f position;
	PLQuaternion orientation;
} PLMBone;

typedef struct PLMSkeletalVertex {
	unsigned int weightIndex;
} PLMSkeletalVertex;

typedef struct PLMSkeletalModelData {
	unsigned int rootIndex; /* root bone */

	PLMBone *bones;        /* list of bones */
	unsigned int numBones; /* number of bones in the array */

	unsigned int numBoneWeights; /* should be the same as the number of vertices */
	PLMBoneWeight *weights;

	// this should match the vertices under your meshes!
	PLMSkeletalVertex **vertices;
} PLMSkeletalModelData;

typedef struct PLMModel {
	char name[ 64 ];
	char path[ PL_SYSTEM_MAX_PATH ];
	PLMModelType type;
	uint16_t flags;

	/* used for visibility culling */
	float radius;
	PLCollisionAABB bounds;

	/* transformations */
	PLMatrix4 modelMatrix;

	PLGMesh **meshes;
	unsigned int numMeshes;

	PLPath *materials;
	unsigned int numMaterials;

	void *userData; /* for storing material references etc. */

	struct {
		/* model type data */
		union {
			PLMSkeletalModelData skeletal_data; /* skeletal animation data */
			PLMVertexAnimModelData vertex_data; /* per-vertex animation data */
		};
	} internal;
} PLMModel;

PL_EXTERN_C

#if !defined( PL_COMPILE_PLUGIN )

PLMModel *PlmCreateStaticModel( PLGMesh **meshes, unsigned int numMeshes );
PLMModel *PlmCreateBasicStaticModel( PLGMesh *mesh );
PLMModel *PlmCreateSkeletalModel( PLGMesh **meshes, unsigned int numMeshes, PLMBone *bones, unsigned int numBones, PLMBoneWeight *weights, unsigned int numWeights );
PLMModel *PlmCreateBasicSkeletalModel( PLGMesh *mesh, PLMBone *bones, unsigned int numBones, PLMBoneWeight *weights, unsigned int numWeights );

PLMModel *PlmLoadModel( const char *path );

PLMModel *PlmParseU3dModel( PLFile *file );
PLMModel *PlmParseHdvModel( PLFile *file );
PLMModel *PlmParseRequiemModel( PLFile *file );
PLMModel *PlmParseObjModel( PLFile *file );
PLMModel *PlmParseCpjModel( PLFile *file );

bool PlmWriteSmdModel( PLMModel *model, const char *path );
bool PlmWriteObjModel( PLMModel *model, const char *path );

void PlmDestroyModel( PLMModel *model );

void PlmGenerateModelNormals( PLMModel *model, bool perFace );
void PlmGenerateModelBounds( PLMModel *model );

#endif

enum {
	PLM_MODEL_FILEFORMAT_ALL = 0,

	PL_BITFLAG( PLM_MODEL_FILEFORMAT_CYCLONE, 0 ),
	PL_BITFLAG( PLM_MODEL_FILEFORMAT_HDV, 1 ),
	PL_BITFLAG( PLM_MODEL_FILEFORMAT_U3D, 2 ),
	PL_BITFLAG( PLM_MODEL_FILEFORMAT_OBJ, 3 ),
	PL_BITFLAG( PLM_MODEL_FILEFORMAT_CPJ, 4 ),
	PL_BITFLAG( PLM_MODEL_FILEFORMAT_PLY, 5 ),
};

#if !defined( PL_COMPILE_PLUGIN )

void PlmRegisterModelLoader( const char *ext, PLMModel *( *Deserialize )( PLFile * ) );
void PlmRegisterStandardModelLoaders( unsigned int flags );
void PlmClearModelLoaders( void );

#endif

typedef enum PLModelOutputType {
	PLM_MODEL_OUTPUT_DEFAULT,
	PLM_MODEL_OUTPUT_SMD,

	PLM_MAX_MODEL_OUTPUT_FORMATS
} PLMModelOutputType;

#if !defined( PL_COMPILE_PLUGIN )

bool PlmWriteModel( const char *path, PLMModel *model, PLMModelOutputType type );

#endif

PL_EXTERN_C_END
